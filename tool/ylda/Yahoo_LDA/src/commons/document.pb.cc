/*******************************************************************************
    Copyright (c) 2011 Yahoo! Inc. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. See accompanying LICENSE file.

    The Initial Developer of the Original Code is Shravan Narayanamurthy.
******************************************************************************/
// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "document.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace LDA {

namespace {

const ::google::protobuf::Descriptor* unigram_document_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  unigram_document_reflection_ = NULL;
const ::google::protobuf::Descriptor* unigram_counts_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  unigram_counts_reflection_ = NULL;
const ::google::protobuf::Descriptor* word_ind_pair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  word_ind_pair_reflection_ = NULL;
const ::google::protobuf::Descriptor* header_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  header_reflection_ = NULL;
const ::google::protobuf::Descriptor* parameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  parameters_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_document_2eproto() {
  protobuf_AddDesc_document_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "document.proto");
  GOOGLE_CHECK(file != NULL);
  unigram_document_descriptor_ = file->message_type(0);
  static const int unigram_document_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, docid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, body_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, topic_assignment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, topic_counts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, cnt_topics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, topic_distribution_),
  };
  unigram_document_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      unigram_document_descriptor_,
      unigram_document::default_instance_,
      unigram_document_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_document, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(unigram_document));
  unigram_counts_descriptor_ = file->message_type(1);
  static const int unigram_counts_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_counts, counts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_counts, tokens_per_topic_),
  };
  unigram_counts_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      unigram_counts_descriptor_,
      unigram_counts::default_instance_,
      unigram_counts_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_counts, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(unigram_counts, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(unigram_counts));
  word_ind_pair_descriptor_ = file->message_type(2);
  static const int word_ind_pair_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(word_ind_pair, word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(word_ind_pair, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(word_ind_pair, frequency_),
  };
  word_ind_pair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      word_ind_pair_descriptor_,
      word_ind_pair::default_instance_,
      word_ind_pair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(word_ind_pair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(word_ind_pair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(word_ind_pair));
  header_descriptor_ = file->message_type(3);
  static const int header_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(header, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(header, num_words_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(header, num_topics_),
  };
  header_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      header_descriptor_,
      header::default_instance_,
      header_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(header, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(header, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(header));
  parameters_descriptor_ = file->message_type(4);
  static const int parameters_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(parameters, alphasum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(parameters, alphas_),
  };
  parameters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      parameters_descriptor_,
      parameters::default_instance_,
      parameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(parameters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(parameters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(parameters));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_document_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    unigram_document_descriptor_, &unigram_document::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    unigram_counts_descriptor_, &unigram_counts::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    word_ind_pair_descriptor_, &word_ind_pair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    header_descriptor_, &header::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    parameters_descriptor_, &parameters::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_document_2eproto() {
  delete unigram_document::default_instance_;
  delete unigram_document_reflection_;
  delete unigram_counts::default_instance_;
  delete unigram_counts_reflection_;
  delete word_ind_pair::default_instance_;
  delete word_ind_pair_reflection_;
  delete header::default_instance_;
  delete header_reflection_;
  delete parameters::default_instance_;
  delete parameters_reflection_;
}

void protobuf_AddDesc_document_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016document.proto\022\003LDA\"\260\001\n\020unigram_docume"
    "nt\022\r\n\005docID\030\001 \001(\t\022\013\n\003url\030\002 \001(\t\022\020\n\004body\030\003"
    " \003(\rB\002\020\001\022\034\n\020topic_assignment\030\004 \003(\rB\002\020\001\022\030"
    "\n\014topic_counts\030\005 \003(\rB\002\020\001\022\026\n\ncnt_topics\030\006"
    " \003(\004B\002\020\001\022\036\n\022topic_distribution\030\007 \003(\002B\002\020\001"
    "\"B\n\016unigram_counts\022\022\n\006counts\030\001 \003(\004B\002\020\001\022\034"
    "\n\020tokens_per_topic\030\002 \003(\rB\002\020\001\"G\n\rword_ind"
    "_pair\022\014\n\004word\030\001 \003(\t\022\021\n\005index\030\002 \003(\rB\002\020\001\022\025"
    "\n\tfrequency\030\003 \003(\rB\002\020\001\"@\n\006header\022\017\n\007versi"
    "on\030\001 \002(\001\022\021\n\tnum_words\030\002 \001(\r\022\022\n\nnum_topic"
    "s\030\003 \001(\r\"2\n\nparameters\022\020\n\010alphasum\030\001 \001(\001\022"
    "\022\n\006alphas\030\002 \003(\001B\002\020\001B\002H\001", 463);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "document.proto", &protobuf_RegisterTypes);
  unigram_document::default_instance_ = new unigram_document();
  unigram_counts::default_instance_ = new unigram_counts();
  word_ind_pair::default_instance_ = new word_ind_pair();
  header::default_instance_ = new header();
  parameters::default_instance_ = new parameters();
  unigram_document::default_instance_->InitAsDefaultInstance();
  unigram_counts::default_instance_->InitAsDefaultInstance();
  word_ind_pair::default_instance_->InitAsDefaultInstance();
  header::default_instance_->InitAsDefaultInstance();
  parameters::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_document_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_document_2eproto {
  StaticDescriptorInitializer_document_2eproto() {
    protobuf_AddDesc_document_2eproto();
  }
} static_descriptor_initializer_document_2eproto_;


// ===================================================================

const ::std::string unigram_document::_default_docid_;
const ::std::string unigram_document::_default_url_;
#ifndef _MSC_VER
const int unigram_document::kDocIDFieldNumber;
const int unigram_document::kUrlFieldNumber;
const int unigram_document::kBodyFieldNumber;
const int unigram_document::kTopicAssignmentFieldNumber;
const int unigram_document::kTopicCountsFieldNumber;
const int unigram_document::kCntTopicsFieldNumber;
const int unigram_document::kTopicDistributionFieldNumber;
#endif  // !_MSC_VER

unigram_document::unigram_document() {
  SharedCtor();
}

void unigram_document::InitAsDefaultInstance() {
}

unigram_document::unigram_document(const unigram_document& from) {
  SharedCtor();
  MergeFrom(from);
}

void unigram_document::SharedCtor() {
  _cached_size_ = 0;
  docid_ = const_cast< ::std::string*>(&_default_docid_);
  url_ = const_cast< ::std::string*>(&_default_url_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

unigram_document::~unigram_document() {
  SharedDtor();
}

void unigram_document::SharedDtor() {
  if (docid_ != &_default_docid_) {
    delete docid_;
  }
  if (url_ != &_default_url_) {
    delete url_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* unigram_document::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unigram_document_descriptor_;
}

const unigram_document& unigram_document::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_document_2eproto();  return *default_instance_;
}

unigram_document* unigram_document::default_instance_ = NULL;

unigram_document* unigram_document::New() const {
  return new unigram_document;
}

void unigram_document::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (docid_ != &_default_docid_) {
        docid_->clear();
      }
    }
    if (_has_bit(1)) {
      if (url_ != &_default_url_) {
        url_->clear();
      }
    }
  }
  body_.Clear();
  topic_assignment_.Clear();
  topic_counts_.Clear();
  cnt_topics_.Clear();
  topic_distribution_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool unigram_document::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string docID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_docid()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->docid().data(), this->docid().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_url;
        break;
      }
      
      // optional string url = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_url:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_url()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->url().data(), this->url().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_body;
        break;
      }
      
      // repeated uint32 body = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_body:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_body(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(34)) goto parse_topic_assignment;
        break;
      }
      
      // repeated uint32 topic_assignment = 4 [packed = true];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_topic_assignment:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_topic_assignment(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(42)) goto parse_topic_counts;
        break;
      }
      
      // repeated uint32 topic_counts = 5 [packed = true];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_topic_counts:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_topic_counts(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(50)) goto parse_cnt_topics;
        break;
      }
      
      // repeated uint64 cnt_topics = 6 [packed = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_cnt_topics:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint64 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt64(
                  input, &value));
            add_cnt_topics(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(58)) goto parse_topic_distribution;
        break;
      }
      
      // repeated float topic_distribution = 7 [packed = true];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_topic_distribution:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            float value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadFloat(
                  input, &value));
            add_topic_distribution(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void unigram_document::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    unigram_document::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string docID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->docid(), output);
  }
  
  // optional string url = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->url(), output);
  }
  
  // repeated uint32 body = 3 [packed = true];
  if (this->body_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_body_cached_byte_size_);
  }
  for (int i = 0; i < this->body_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->body(i), output);
  }
  
  // repeated uint32 topic_assignment = 4 [packed = true];
  if (this->topic_assignment_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_topic_assignment_cached_byte_size_);
  }
  for (int i = 0; i < this->topic_assignment_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->topic_assignment(i), output);
  }
  
  // repeated uint32 topic_counts = 5 [packed = true];
  if (this->topic_counts_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_topic_counts_cached_byte_size_);
  }
  for (int i = 0; i < this->topic_counts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->topic_counts(i), output);
  }
  
  // repeated uint64 cnt_topics = 6 [packed = true];
  if (this->cnt_topics_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_cnt_topics_cached_byte_size_);
  }
  for (int i = 0; i < this->cnt_topics_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64NoTag(
      this->cnt_topics(i), output);
  }
  
  // repeated float topic_distribution = 7 [packed = true];
  if (this->topic_distribution_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(7, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_topic_distribution_cached_byte_size_);
  }
  for (int i = 0; i < this->topic_distribution_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->topic_distribution(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* unigram_document::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string docID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->docid(), target);
  }
  
  // optional string url = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->url(), target);
  }
  
  // repeated uint32 body = 3 [packed = true];
  if (this->body_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _body_cached_byte_size_, target);
  }
  for (int i = 0; i < this->body_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->body(i), target);
  }
  
  // repeated uint32 topic_assignment = 4 [packed = true];
  if (this->topic_assignment_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _topic_assignment_cached_byte_size_, target);
  }
  for (int i = 0; i < this->topic_assignment_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->topic_assignment(i), target);
  }
  
  // repeated uint32 topic_counts = 5 [packed = true];
  if (this->topic_counts_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _topic_counts_cached_byte_size_, target);
  }
  for (int i = 0; i < this->topic_counts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->topic_counts(i), target);
  }
  
  // repeated uint64 cnt_topics = 6 [packed = true];
  if (this->cnt_topics_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _cnt_topics_cached_byte_size_, target);
  }
  for (int i = 0; i < this->cnt_topics_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64NoTagToArray(this->cnt_topics(i), target);
  }
  
  // repeated float topic_distribution = 7 [packed = true];
  if (this->topic_distribution_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      7,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _topic_distribution_cached_byte_size_, target);
  }
  for (int i = 0; i < this->topic_distribution_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->topic_distribution(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int unigram_document::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string docID = 1;
    if (has_docid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->docid());
    }
    
    // optional string url = 2;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }
    
  }
  // repeated uint32 body = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->body_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->body(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _body_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 topic_assignment = 4 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->topic_assignment_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->topic_assignment(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _topic_assignment_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 topic_counts = 5 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->topic_counts_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->topic_counts(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _topic_counts_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint64 cnt_topics = 6 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->cnt_topics_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->cnt_topics(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _cnt_topics_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated float topic_distribution = 7 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->topic_distribution_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _topic_distribution_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void unigram_document::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const unigram_document* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const unigram_document*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void unigram_document::MergeFrom(const unigram_document& from) {
  GOOGLE_CHECK_NE(&from, this);
  body_.MergeFrom(from.body_);
  topic_assignment_.MergeFrom(from.topic_assignment_);
  topic_counts_.MergeFrom(from.topic_counts_);
  cnt_topics_.MergeFrom(from.cnt_topics_);
  topic_distribution_.MergeFrom(from.topic_distribution_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_docid(from.docid());
    }
    if (from._has_bit(1)) {
      set_url(from.url());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void unigram_document::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void unigram_document::CopyFrom(const unigram_document& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool unigram_document::IsInitialized() const {
  
  return true;
}

void unigram_document::Swap(unigram_document* other) {
  if (other != this) {
    std::swap(docid_, other->docid_);
    std::swap(url_, other->url_);
    body_.Swap(&other->body_);
    topic_assignment_.Swap(&other->topic_assignment_);
    topic_counts_.Swap(&other->topic_counts_);
    cnt_topics_.Swap(&other->cnt_topics_);
    topic_distribution_.Swap(&other->topic_distribution_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata unigram_document::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = unigram_document_descriptor_;
  metadata.reflection = unigram_document_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int unigram_counts::kCountsFieldNumber;
const int unigram_counts::kTokensPerTopicFieldNumber;
#endif  // !_MSC_VER

unigram_counts::unigram_counts() {
  SharedCtor();
}

void unigram_counts::InitAsDefaultInstance() {
}

unigram_counts::unigram_counts(const unigram_counts& from) {
  SharedCtor();
  MergeFrom(from);
}

void unigram_counts::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

unigram_counts::~unigram_counts() {
  SharedDtor();
}

void unigram_counts::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* unigram_counts::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return unigram_counts_descriptor_;
}

const unigram_counts& unigram_counts::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_document_2eproto();  return *default_instance_;
}

unigram_counts* unigram_counts::default_instance_ = NULL;

unigram_counts* unigram_counts::New() const {
  return new unigram_counts;
}

void unigram_counts::Clear() {
  counts_.Clear();
  tokens_per_topic_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool unigram_counts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 counts = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint64 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt64(
                  input, &value));
            add_counts(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(18)) goto parse_tokens_per_topic;
        break;
      }
      
      // repeated uint32 tokens_per_topic = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_tokens_per_topic:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_tokens_per_topic(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void unigram_counts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    unigram_counts::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated uint64 counts = 1 [packed = true];
  if (this->counts_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_counts_cached_byte_size_);
  }
  for (int i = 0; i < this->counts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64NoTag(
      this->counts(i), output);
  }
  
  // repeated uint32 tokens_per_topic = 2 [packed = true];
  if (this->tokens_per_topic_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_tokens_per_topic_cached_byte_size_);
  }
  for (int i = 0; i < this->tokens_per_topic_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->tokens_per_topic(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* unigram_counts::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint64 counts = 1 [packed = true];
  if (this->counts_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      1,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _counts_cached_byte_size_, target);
  }
  for (int i = 0; i < this->counts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64NoTagToArray(this->counts(i), target);
  }
  
  // repeated uint32 tokens_per_topic = 2 [packed = true];
  if (this->tokens_per_topic_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _tokens_per_topic_cached_byte_size_, target);
  }
  for (int i = 0; i < this->tokens_per_topic_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->tokens_per_topic(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int unigram_counts::ByteSize() const {
  int total_size = 0;
  
  // repeated uint64 counts = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->counts_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->counts(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _counts_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 tokens_per_topic = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->tokens_per_topic_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tokens_per_topic(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _tokens_per_topic_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void unigram_counts::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const unigram_counts* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const unigram_counts*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void unigram_counts::MergeFrom(const unigram_counts& from) {
  GOOGLE_CHECK_NE(&from, this);
  counts_.MergeFrom(from.counts_);
  tokens_per_topic_.MergeFrom(from.tokens_per_topic_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void unigram_counts::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void unigram_counts::CopyFrom(const unigram_counts& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool unigram_counts::IsInitialized() const {
  
  return true;
}

void unigram_counts::Swap(unigram_counts* other) {
  if (other != this) {
    counts_.Swap(&other->counts_);
    tokens_per_topic_.Swap(&other->tokens_per_topic_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata unigram_counts::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = unigram_counts_descriptor_;
  metadata.reflection = unigram_counts_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int word_ind_pair::kWordFieldNumber;
const int word_ind_pair::kIndexFieldNumber;
const int word_ind_pair::kFrequencyFieldNumber;
#endif  // !_MSC_VER

word_ind_pair::word_ind_pair() {
  SharedCtor();
}

void word_ind_pair::InitAsDefaultInstance() {
}

word_ind_pair::word_ind_pair(const word_ind_pair& from) {
  SharedCtor();
  MergeFrom(from);
}

void word_ind_pair::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

word_ind_pair::~word_ind_pair() {
  SharedDtor();
}

void word_ind_pair::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* word_ind_pair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return word_ind_pair_descriptor_;
}

const word_ind_pair& word_ind_pair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_document_2eproto();  return *default_instance_;
}

word_ind_pair* word_ind_pair::default_instance_ = NULL;

word_ind_pair* word_ind_pair::New() const {
  return new word_ind_pair;
}

void word_ind_pair::Clear() {
  word_.Clear();
  index_.Clear();
  frequency_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool word_ind_pair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string word = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_word:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->add_word()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->word(0).data(), this->word(0).length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(10)) goto parse_word;
        if (input->ExpectTag(18)) goto parse_index;
        break;
      }
      
      // repeated uint32 index = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_index:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_index(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectTag(26)) goto parse_frequency;
        break;
      }
      
      // repeated uint32 frequency = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_frequency:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            ::google::protobuf::uint32 value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
                  input, &value));
            add_frequency(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void word_ind_pair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    word_ind_pair::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated string word = 1;
  for (int i = 0; i < this->word_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->word(i).data(), this->word(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->word(i), output);
  }
  
  // repeated uint32 index = 2 [packed = true];
  if (this->index_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_index_cached_byte_size_);
  }
  for (int i = 0; i < this->index_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->index(i), output);
  }
  
  // repeated uint32 frequency = 3 [packed = true];
  if (this->frequency_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_frequency_cached_byte_size_);
  }
  for (int i = 0; i < this->frequency_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->frequency(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* word_ind_pair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated string word = 1;
  for (int i = 0; i < this->word_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->word(i).data(), this->word(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->word(i), target);
  }
  
  // repeated uint32 index = 2 [packed = true];
  if (this->index_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _index_cached_byte_size_, target);
  }
  for (int i = 0; i < this->index_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->index(i), target);
  }
  
  // repeated uint32 frequency = 3 [packed = true];
  if (this->frequency_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _frequency_cached_byte_size_, target);
  }
  for (int i = 0; i < this->frequency_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->frequency(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int word_ind_pair::ByteSize() const {
  int total_size = 0;
  
  // repeated string word = 1;
  total_size += 1 * this->word_size();
  for (int i = 0; i < this->word_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->word(i));
  }
  
  // repeated uint32 index = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->index_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->index(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _index_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  // repeated uint32 frequency = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->frequency_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->frequency(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _frequency_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void word_ind_pair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const word_ind_pair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const word_ind_pair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void word_ind_pair::MergeFrom(const word_ind_pair& from) {
  GOOGLE_CHECK_NE(&from, this);
  word_.MergeFrom(from.word_);
  index_.MergeFrom(from.index_);
  frequency_.MergeFrom(from.frequency_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void word_ind_pair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void word_ind_pair::CopyFrom(const word_ind_pair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool word_ind_pair::IsInitialized() const {
  
  return true;
}

void word_ind_pair::Swap(word_ind_pair* other) {
  if (other != this) {
    word_.Swap(&other->word_);
    index_.Swap(&other->index_);
    frequency_.Swap(&other->frequency_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata word_ind_pair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = word_ind_pair_descriptor_;
  metadata.reflection = word_ind_pair_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int header::kVersionFieldNumber;
const int header::kNumWordsFieldNumber;
const int header::kNumTopicsFieldNumber;
#endif  // !_MSC_VER

header::header() {
  SharedCtor();
}

void header::InitAsDefaultInstance() {
}

header::header(const header& from) {
  SharedCtor();
  MergeFrom(from);
}

void header::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  num_words_ = 0u;
  num_topics_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

header::~header() {
  SharedDtor();
}

void header::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* header::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return header_descriptor_;
}

const header& header::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_document_2eproto();  return *default_instance_;
}

header* header::default_instance_ = NULL;

header* header::New() const {
  return new header;
}

void header::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
    num_words_ = 0u;
    num_topics_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &version_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_num_words;
        break;
      }
      
      // optional uint32 num_words = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_num_words:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &num_words_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_num_topics;
        break;
      }
      
      // optional uint32 num_topics = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_num_topics:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &num_topics_));
        _set_bit(2);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    header::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required double version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->version(), output);
  }
  
  // optional uint32 num_words = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->num_words(), output);
  }
  
  // optional uint32 num_topics = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->num_topics(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* header::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->version(), target);
  }
  
  // optional uint32 num_words = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->num_words(), target);
  }
  
  // optional uint32 num_topics = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->num_topics(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int header::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double version = 1;
    if (has_version()) {
      total_size += 1 + 8;
    }
    
    // optional uint32 num_words = 2;
    if (has_num_words()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_words());
    }
    
    // optional uint32 num_topics = 3;
    if (has_num_topics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_topics());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void header::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const header* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const header*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void header::MergeFrom(const header& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_num_words(from.num_words());
    }
    if (from._has_bit(2)) {
      set_num_topics(from.num_topics());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void header::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void header::CopyFrom(const header& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool header::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void header::Swap(header* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(num_words_, other->num_words_);
    std::swap(num_topics_, other->num_topics_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata header::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = header_descriptor_;
  metadata.reflection = header_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int parameters::kAlphasumFieldNumber;
const int parameters::kAlphasFieldNumber;
#endif  // !_MSC_VER

parameters::parameters() {
  SharedCtor();
}

void parameters::InitAsDefaultInstance() {
}

parameters::parameters(const parameters& from) {
  SharedCtor();
  MergeFrom(from);
}

void parameters::SharedCtor() {
  _cached_size_ = 0;
  alphasum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

parameters::~parameters() {
  SharedDtor();
}

void parameters::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* parameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return parameters_descriptor_;
}

const parameters& parameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_document_2eproto();  return *default_instance_;
}

parameters* parameters::default_instance_ = NULL;

parameters* parameters::New() const {
  return new parameters;
}

void parameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    alphasum_ = 0;
  }
  alphas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool parameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double alphasum = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &alphasum_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_alphas;
        break;
      }
      
      // repeated double alphas = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_alphas:
        {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit =
              input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            double value;
            DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
                  input, &value));
            add_alphas(value);
          }
          input->PopLimit(limit);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void parameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    parameters::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional double alphasum = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->alphasum(), output);
  }
  
  // repeated double alphas = 2 [packed = true];
  if (this->alphas_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_alphas_cached_byte_size_);
  }
  for (int i = 0; i < this->alphas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->alphas(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* parameters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional double alphasum = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->alphasum(), target);
  }
  
  // repeated double alphas = 2 [packed = true];
  if (this->alphas_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _alphas_cached_byte_size_, target);
  }
  for (int i = 0; i < this->alphas_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->alphas(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int parameters::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double alphasum = 1;
    if (has_alphasum()) {
      total_size += 1 + 8;
    }
    
  }
  // repeated double alphas = 2 [packed = true];
  {
    int data_size = 0;
    data_size = 8 * this->alphas_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    _alphas_cached_byte_size_ = data_size;
    total_size += data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void parameters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const parameters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const parameters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void parameters::MergeFrom(const parameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  alphas_.MergeFrom(from.alphas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_alphasum(from.alphasum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void parameters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void parameters::CopyFrom(const parameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool parameters::IsInitialized() const {
  
  return true;
}

void parameters::Swap(parameters* other) {
  if (other != this) {
    std::swap(alphasum_, other->alphasum_);
    alphas_.Swap(&other->alphas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata parameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = parameters_descriptor_;
  metadata.reflection = parameters_reflection_;
  return metadata;
}


}  // namespace LDA
