/*******************************************************************************
    Copyright (c) 2011 Yahoo! Inc. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. See accompanying LICENSE file.

    The Initial Developer of the Original Code is Shravan Narayanamurthy.
******************************************************************************/
// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `DistributedMap.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef __DistributedMap_h__
#define __DistributedMap_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace GlobalTable
{

class DistributedMap;

}

}

namespace GlobalTable
{

class DistributedMap;
bool operator==(const DistributedMap&, const DistributedMap&);
bool operator<(const DistributedMap&, const DistributedMap&);

}

namespace IceInternal
{

::Ice::Object* upCast(::GlobalTable::DistributedMap*);
::IceProxy::Ice::Object* upCast(::IceProxy::GlobalTable::DistributedMap*);

}

namespace GlobalTable
{

typedef ::IceInternal::Handle< ::GlobalTable::DistributedMap> DistributedMapPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::GlobalTable::DistributedMap> DistributedMapPrx;

void __read(::IceInternal::BasicStream*, DistributedMapPrx&);
void __patch__DistributedMapPtr(void*, ::Ice::ObjectPtr&);

}

namespace GlobalTable
{

class AMD_DistributedMap_putNget : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::std::string&) = 0;
};

typedef ::IceUtil::Handle< ::GlobalTable::AMD_DistributedMap_putNget> AMD_DistributedMap_putNgetPtr;

class AMD_DistributedMap_waitForAllClients : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::GlobalTable::AMD_DistributedMap_waitForAllClients> AMD_DistributedMap_waitForAllClientsPtr;

}

namespace IceAsync
{

namespace GlobalTable
{

class AMD_DistributedMap_putNget : public ::GlobalTable::AMD_DistributedMap_putNget, public ::IceInternal::IncomingAsync
{
public:

    AMD_DistributedMap_putNget(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::string&);
};

class AMD_DistributedMap_waitForAllClients : public ::GlobalTable::AMD_DistributedMap_waitForAllClients, public ::IceInternal::IncomingAsync
{
public:

    AMD_DistributedMap_waitForAllClients(::IceInternal::Incoming&);

    virtual void ice_response();
};

}

}

namespace GlobalTable
{

class Callback_DistributedMap_put_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_put_Base> Callback_DistributedMap_putPtr;

class Callback_DistributedMap_set_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_set_Base> Callback_DistributedMap_setPtr;

class Callback_DistributedMap_remove_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_remove_Base> Callback_DistributedMap_removePtr;

class Callback_DistributedMap_putNget_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_putNget_Base> Callback_DistributedMap_putNgetPtr;

class Callback_DistributedMap_get_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_get_Base> Callback_DistributedMap_getPtr;

class Callback_DistributedMap_waitForAllClients_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DistributedMap_waitForAllClients_Base> Callback_DistributedMap_waitForAllClientsPtr;

}

namespace IceProxy
{

namespace GlobalTable
{

class DistributedMap : virtual public ::IceProxy::Ice::Object
{
public:

    void put(const ::std::string& s, const ::std::string& delta)
    {
        put(s, delta, 0);
    }
    void put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx)
    {
        put(s, delta, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta)
    {
        return begin_put(s, delta, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx)
    {
        return begin_put(s, delta, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_put(s, delta, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_put(s, delta, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta, const ::GlobalTable::Callback_DistributedMap_putPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_put(s, delta, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_putPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_put(s, delta, &__ctx, __del, __cookie);
    }

    void end_put(const ::Ice::AsyncResultPtr&);
    
private:

    void put(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_put(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void set(const ::std::string& s, const ::std::string& counts)
    {
        set(s, counts, 0);
    }
    void set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context& __ctx)
    {
        set(s, counts, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts)
    {
        return begin_set(s, counts, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context& __ctx)
    {
        return begin_set(s, counts, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_set(s, counts, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_set(s, counts, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts, const ::GlobalTable::Callback_DistributedMap_setPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_set(s, counts, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_setPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_set(s, counts, &__ctx, __del, __cookie);
    }

    void end_set(const ::Ice::AsyncResultPtr&);
    
private:

    void set(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_set(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool remove(const ::std::string& s, ::std::string& counts)
    {
        return remove(s, counts, 0);
    }
    bool remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context& __ctx)
    {
        return remove(s, counts, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s)
    {
        return begin_remove(s, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s, const ::Ice::Context& __ctx)
    {
        return begin_remove(s, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(s, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s, const ::GlobalTable::Callback_DistributedMap_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& s, const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(s, &__ctx, __del, __cookie);
    }

    bool end_remove(::std::string& counts, const ::Ice::AsyncResultPtr&);
    
private:

    bool remove(const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_remove(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts)
    {
        putNget(s, delta, counts, 0);
    }
    void putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts, const ::Ice::Context& __ctx)
    {
        putNget(s, delta, counts, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta)
    {
        return begin_putNget(s, delta, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx)
    {
        return begin_putNget(s, delta, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_putNget(s, delta, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_putNget(s, delta, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta, const ::GlobalTable::Callback_DistributedMap_putNgetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_putNget(s, delta, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_putNgetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_putNget(s, delta, &__ctx, __del, __cookie);
    }

    void end_putNget(::std::string& counts, const ::Ice::AsyncResultPtr&);
    
private:

    void putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_putNget(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool get(const ::std::string& s, ::std::string& counts)
    {
        return get(s, counts, 0);
    }
    bool get(const ::std::string& s, ::std::string& counts, const ::Ice::Context& __ctx)
    {
        return get(s, counts, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s)
    {
        return begin_get(s, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s, const ::Ice::Context& __ctx)
    {
        return begin_get(s, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_get(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_get(s, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s, const ::GlobalTable::Callback_DistributedMap_getPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_get(s, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_get(const ::std::string& s, const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_getPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_get(s, &__ctx, __del, __cookie);
    }

    bool end_get(::std::string& counts, const ::Ice::AsyncResultPtr&);
    
private:

    bool get(const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_get(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void waitForAllClients()
    {
        waitForAllClients(0);
    }
    void waitForAllClients(const ::Ice::Context& __ctx)
    {
        waitForAllClients(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients()
    {
        return begin_waitForAllClients(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::Ice::Context& __ctx)
    {
        return begin_waitForAllClients(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_waitForAllClients(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_waitForAllClients(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::GlobalTable::Callback_DistributedMap_waitForAllClientsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_waitForAllClients(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::Ice::Context& __ctx, const ::GlobalTable::Callback_DistributedMap_waitForAllClientsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_waitForAllClients(&__ctx, __del, __cookie);
    }

    void end_waitForAllClients(const ::Ice::AsyncResultPtr&);
    
private:

    void waitForAllClients(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_waitForAllClients(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<DistributedMap> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<DistributedMap*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<DistributedMap*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace GlobalTable
{

class DistributedMap : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void put(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void set(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual bool remove(const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual void putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual bool get(const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual void waitForAllClients(const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace GlobalTable
{

class DistributedMap : virtual public ::IceDelegate::GlobalTable::DistributedMap,
                       virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void put(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void set(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual bool remove(const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual void putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual bool get(const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual void waitForAllClients(const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace GlobalTable
{

class DistributedMap : virtual public ::IceDelegate::GlobalTable::DistributedMap,
                       virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void put(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void set(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual bool remove(const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual void putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual bool get(const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual void waitForAllClients(const ::Ice::Context*);
};

}

}

namespace GlobalTable
{

class DistributedMap : virtual public ::Ice::Object
{
public:

    typedef DistributedMapPrx ProxyType;
    typedef DistributedMapPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void put(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___put(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void set(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___set(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool remove(const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___remove(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void putNget_async(const ::GlobalTable::AMD_DistributedMap_putNgetPtr&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___putNget(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool get(const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___get(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void waitForAllClients_async(const ::GlobalTable::AMD_DistributedMap_waitForAllClientsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___waitForAllClients(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const DistributedMap& l, const DistributedMap& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DistributedMap& l, const DistributedMap& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace GlobalTable
{

template<class T>
class CallbackNC_DistributedMap_put : public Callback_DistributedMap_put_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DistributedMap_put(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_put<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_put<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_put<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_put<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_put : public Callback_DistributedMap_put_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DistributedMap_put(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_put<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_put<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_put<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_putPtr
newCallback_DistributedMap_put(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_put<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_DistributedMap_set : public Callback_DistributedMap_set_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DistributedMap_set(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_set<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_set<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_set<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_set<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_set : public Callback_DistributedMap_set_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DistributedMap_set(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_set<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_set<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_set<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_setPtr
newCallback_DistributedMap_set(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_set<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_DistributedMap_remove : public Callback_DistributedMap_remove_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_DistributedMap_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        bool __ret;
        try
        {
            __ret = __proxy->end_remove(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, counts);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, counts);
#endif
        }
    }

    Response response;
};

template<class T> Callback_DistributedMap_removePtr
newCallback_DistributedMap_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_remove<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_removePtr
newCallback_DistributedMap_remove(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_remove<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_remove : public Callback_DistributedMap_remove_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_DistributedMap_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        bool __ret;
        try
        {
            __ret = __proxy->end_remove(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, counts, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, counts, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_DistributedMap_removePtr
newCallback_DistributedMap_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_removePtr
newCallback_DistributedMap_remove(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DistributedMap_putNget : public Callback_DistributedMap_putNget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_DistributedMap_putNget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        try
        {
            __proxy->end_putNget(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(counts);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(counts);
#endif
        }
    }

    Response response;
};

template<class T> Callback_DistributedMap_putNgetPtr
newCallback_DistributedMap_putNget(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_putNget<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_putNgetPtr
newCallback_DistributedMap_putNget(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_putNget<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_putNget : public Callback_DistributedMap_putNget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_DistributedMap_putNget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        try
        {
            __proxy->end_putNget(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(counts, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(counts, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_DistributedMap_putNgetPtr
newCallback_DistributedMap_putNget(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_putNget<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_putNgetPtr
newCallback_DistributedMap_putNget(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_putNget<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DistributedMap_get : public Callback_DistributedMap_get_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_DistributedMap_get(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        bool __ret;
        try
        {
            __ret = __proxy->end_get(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, counts);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, counts);
#endif
        }
    }

    Response response;
};

template<class T> Callback_DistributedMap_getPtr
newCallback_DistributedMap_get(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_get<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_getPtr
newCallback_DistributedMap_get(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_get<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_get : public Callback_DistributedMap_get_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_DistributedMap_get(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::GlobalTable::DistributedMapPrx __proxy = ::GlobalTable::DistributedMapPrx::uncheckedCast(__result->getProxy());
        ::std::string counts;
        bool __ret;
        try
        {
            __ret = __proxy->end_get(counts, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, counts, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, counts, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_DistributedMap_getPtr
newCallback_DistributedMap_get(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_get<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_getPtr
newCallback_DistributedMap_get(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_get<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DistributedMap_waitForAllClients : public Callback_DistributedMap_waitForAllClients_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_DistributedMap_waitForAllClients(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_waitForAllClients<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_waitForAllClients<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_waitForAllClients<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DistributedMap_waitForAllClients<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_DistributedMap_waitForAllClients : public Callback_DistributedMap_waitForAllClients_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_DistributedMap_waitForAllClients(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_waitForAllClients<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_waitForAllClients<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_waitForAllClients<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DistributedMap_waitForAllClientsPtr
newCallback_DistributedMap_waitForAllClients(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DistributedMap_waitForAllClients<T, CT>(instance, 0, excb, sentcb);
}

}

#endif
