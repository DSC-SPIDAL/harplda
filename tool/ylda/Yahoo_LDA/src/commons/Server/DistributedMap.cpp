/*******************************************************************************
    Copyright (c) 2011 Yahoo! Inc. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License. See accompanying LICENSE file.

    The Initial Developer of the Original Code is Shravan Narayanamurthy.
******************************************************************************/
// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `DistributedMap.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#include <DistributedMap.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __GlobalTable__DistributedMap__put_name = "put";

static const ::std::string __GlobalTable__DistributedMap__set_name = "set";

static const ::std::string __GlobalTable__DistributedMap__remove_name = "remove";

static const ::std::string __GlobalTable__DistributedMap__putNget_name = "putNget";

static const ::std::string __GlobalTable__DistributedMap__get_name = "get";

static const ::std::string __GlobalTable__DistributedMap__waitForAllClients_name = "waitForAllClients";

::Ice::Object* IceInternal::upCast(::GlobalTable::DistributedMap* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::GlobalTable::DistributedMap* p) { return p; }

void
GlobalTable::__read(::IceInternal::BasicStream* __is, ::GlobalTable::DistributedMapPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::GlobalTable::DistributedMap;
        v->__copyFrom(proxy);
    }
}

IceAsync::GlobalTable::AMD_DistributedMap_putNget::AMD_DistributedMap_putNget(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::GlobalTable::AMD_DistributedMap_putNget::ice_response(const ::std::string& counts)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = this->__os();
            __os->write(counts);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response(true);
    }
}

IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients::AMD_DistributedMap_waitForAllClients(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients::ice_response()
{
    if(__validateResponse(true))
    {
        __response(true);
    }
}

void
IceProxy::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->put(s, delta, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__put_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__put_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(delta);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_put(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__put_name);
}

void
IceProxy::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->set(s, counts, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__set_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__set_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(counts);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_set(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__set_name);
}

bool
IceProxy::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__remove_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            return __del->remove(s, counts, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_remove(const ::std::string& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__remove_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__remove_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::GlobalTable::DistributedMap::end_remove(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__remove_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::GlobalTable::DistributedMap::putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__putNget_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->putNget(s, delta, counts, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_putNget(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__putNget_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__putNget_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__putNget_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->write(delta);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_putNget(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__putNget_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->endReadEncaps();
}

bool
IceProxy::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__GlobalTable__DistributedMap__get_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            return __del->get(s, counts, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_get(const ::std::string& s, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__GlobalTable__DistributedMap__get_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__get_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__get_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(s);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::GlobalTable::DistributedMap::end_get(::std::string& counts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __GlobalTable__DistributedMap__get_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(counts);
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::GlobalTable::DistributedMap* __del = dynamic_cast< ::IceDelegate::GlobalTable::DistributedMap*>(__delBase.get());
            __del->waitForAllClients(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::GlobalTable::DistributedMap::begin_waitForAllClients(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __GlobalTable__DistributedMap__waitForAllClients_name, __del, __cookie);
    try
    {
        __result->__prepare(__GlobalTable__DistributedMap__waitForAllClients_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::GlobalTable::DistributedMap::end_waitForAllClients(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __GlobalTable__DistributedMap__waitForAllClients_name);
}

const ::std::string&
IceProxy::GlobalTable::DistributedMap::ice_staticId()
{
    return ::GlobalTable::DistributedMap::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::GlobalTable::DistributedMap::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::GlobalTable::DistributedMap);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::GlobalTable::DistributedMap::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::GlobalTable::DistributedMap);
}

::IceProxy::Ice::Object*
IceProxy::GlobalTable::DistributedMap::__newInstance() const
{
    return new DistributedMap;
}

void
IceDelegateM::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__put_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(delta);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__set_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(counts);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::putNget(const ::std::string& s, const ::std::string& delta, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__putNget_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
        __os->write(delta);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->endReadEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__get_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(s);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(counts);
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __GlobalTable__DistributedMap__waitForAllClients_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::GlobalTable::DistributedMap::put(const ::std::string& s, const ::std::string& delta, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& s, const ::std::string& delta, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_s(s),
            _m_delta(delta)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->put(_m_s, _m_delta, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_s;
        const ::std::string& _m_delta;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__put_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(s, delta, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::GlobalTable::DistributedMap::set(const ::std::string& s, const ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& s, const ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->set(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_s;
        const ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__set_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::GlobalTable::DistributedMap::remove(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& s, ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->remove(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_s;
        ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__remove_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::GlobalTable::DistributedMap::putNget(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

bool
IceDelegateD::GlobalTable::DistributedMap::get(const ::std::string& s, ::std::string& counts, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& s, ::std::string& counts, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_s(s),
            _m_counts(counts)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::GlobalTable::DistributedMap* servant = dynamic_cast< ::GlobalTable::DistributedMap*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->get(_m_s, _m_counts, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_s;
        ::std::string& _m_counts;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __GlobalTable__DistributedMap__get_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, s, counts, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::GlobalTable::DistributedMap::waitForAllClients(const ::Ice::Context*)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
}

::Ice::ObjectPtr
GlobalTable::DistributedMap::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __GlobalTable__DistributedMap_ids[2] =
{
    "::GlobalTable::DistributedMap",
    "::Ice::Object"
};

bool
GlobalTable::DistributedMap::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__GlobalTable__DistributedMap_ids, __GlobalTable__DistributedMap_ids + 2, _s);
}

::std::vector< ::std::string>
GlobalTable::DistributedMap::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__GlobalTable__DistributedMap_ids[0], &__GlobalTable__DistributedMap_ids[2]);
}

const ::std::string&
GlobalTable::DistributedMap::ice_id(const ::Ice::Current&) const
{
    return __GlobalTable__DistributedMap_ids[0];
}

const ::std::string&
GlobalTable::DistributedMap::ice_staticId()
{
    return __GlobalTable__DistributedMap_ids[0];
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___put(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string delta;
    __is->read(s);
    __is->read(delta);
    __is->endReadEncaps();
    put(s, delta, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___set(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string counts;
    __is->read(s);
    __is->read(counts);
    __is->endReadEncaps();
    set(s, counts, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___remove(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    __is->read(s);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string counts;
    bool __ret = remove(s, counts, __current);
    __os->write(counts);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___putNget(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    ::std::string delta;
    __is->read(s);
    __is->read(delta);
    __is->endReadEncaps();
    ::GlobalTable::AMD_DistributedMap_putNgetPtr __cb = new IceAsync::GlobalTable::AMD_DistributedMap_putNget(__inS);
    try
    {
        putNget_async(__cb, s, delta, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___get(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string s;
    __is->read(s);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string counts;
    bool __ret = get(s, counts, __current);
    __os->write(counts);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
GlobalTable::DistributedMap::___waitForAllClients(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::GlobalTable::AMD_DistributedMap_waitForAllClientsPtr __cb = new IceAsync::GlobalTable::AMD_DistributedMap_waitForAllClients(__inS);
    try
    {
        waitForAllClients_async(__cb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

static ::std::string __GlobalTable__DistributedMap_all[] =
{
    "get",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "put",
    "putNget",
    "remove",
    "set",
    "waitForAllClients"
};

::Ice::DispatchStatus
GlobalTable::DistributedMap::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__GlobalTable__DistributedMap_all, __GlobalTable__DistributedMap_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __GlobalTable__DistributedMap_all)
    {
        case 0:
        {
            return ___get(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___put(in, current);
        }
        case 6:
        {
            return ___putNget(in, current);
        }
        case 7:
        {
            return ___remove(in, current);
        }
        case 8:
        {
            return ___set(in, current);
        }
        case 9:
        {
            return ___waitForAllClients(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
GlobalTable::DistributedMap::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
GlobalTable::DistributedMap::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
GlobalTable::DistributedMap::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type GlobalTable::DistributedMap was not generated with stream support";
    throw ex;
}

void
GlobalTable::DistributedMap::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type GlobalTable::DistributedMap was not generated with stream support";
    throw ex;
}
#endif

void 
GlobalTable::__patch__DistributedMapPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::GlobalTable::DistributedMapPtr* p = static_cast< ::GlobalTable::DistributedMapPtr*>(__addr);
    assert(p);
    *p = ::GlobalTable::DistributedMapPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::GlobalTable::DistributedMap::ice_staticId(), v->ice_id());
    }
}
